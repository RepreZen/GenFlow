/*******************************************************************************
 * Copyright Â© 2013, 2016 Modelsolv, Inc.
 * All Rights Reserved.
 *
 * NOTICE: All information contained herein is, and remains the property
 * of ModelSolv, Inc. See the file license.html in the root directory of
 * this project for further information.
 *******************************************************************************/
package com.reprezen.genflow.rapidml.jsonschema.help;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import org.eclipse.emf.common.util.Monitor;
import org.hamcrest.BaseMatcher;
import org.hamcrest.Matcher;
import org.junit.Assert;
import org.junit.runner.Description;

import com.fasterxml.jackson.core.JsonFactory;
import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.JsonNodeType;
import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;
import com.reprezen.genflow.api.template.FakeGenTemplateContext;
import com.reprezen.genflow.rapidml.jsonschema.XGenerateJsonSchema;
import com.reprezen.genflow.test.common.GeneratorTestFixture;
import com.reprezen.rapidml.ZenModel;
import com.reprezen.rapidml.implicit.ZenModelNormalizer;

/**
 * A test fixture for artifacts generated by JSON Scheme generator.
 * 
 * @author Andrey Martianov <andrey.martianov@xored.com>
 * 
 */
public class JSONSchemeGeneratorTestFixture extends GeneratorTestFixture {

	private JsonNode root = null;

	public JSONSchemeGeneratorTestFixture() {
		super("json"); //$NON-NLS-1$
	}

	@Override
	protected Map<String, String> doGenerate(ZenModel zenModel, File dir, Monitor progressMonitor) throws IOException {
		new ZenModelNormalizer().normalize(zenModel);
		XGenerateJsonSchema generator = new XGenerateJsonSchema();
		generator.init(new FakeGenTemplateContext());
		String result = generator.generate(zenModel);
		return Collections.singletonMap("jsonScheme.json", result); //$NON-NLS-1$
	}

	@Override
	protected String getSampleRestName(Description description) {
		Class<?> class_;
		try {
			// A workaround for java.lang.ClassNotFoundException thrown by
			// description.getMethodClass
			class_ = Class.forName(description.getClassName());
		} catch (ClassNotFoundException e) {
			e.printStackTrace();
			throw new RuntimeException(e);
		}
		SampleRestFile result = class_.getAnnotation(SampleRestFile.class);
		return result.value();
	}

	public JsonNode getRoot() throws JsonParseException, IOException {
		ObjectMapper mapper = new ObjectMapper();
		return getRoot(mapper);
	}

	public JsonNode getRoot(ObjectMapper mapper) throws JsonParseException, IOException {
		if (null == root) {
			JsonFactory factory = new JsonFactory();
			JsonParser parser = factory.createParser(generatedFile);
			root = mapper.readTree(parser);
		}
		return root;
	}

	public String getJson() throws IOException {
		return new String(Files.readAllBytes(generatedFile.toPath()));
	}

	public static void checkFieldValue(String field, JsonNode jsonNode, String expectedValue) {
		JsonNode chJsonNode = jsonNode.get(field);
		Assert.assertNotNull("Node not contains field \"" + field + "\"", chJsonNode); //$NON-NLS-1$ //$NON-NLS-2$
		Assert.assertEquals("Invalid \"" + field + "\" field", expectedValue, chJsonNode.asText()); //$NON-NLS-1$//$NON-NLS-2$
	}

	public static void checkFieldValue(String field, JsonNode jsonNode, boolean expectedValue) {
		JsonNode chJsonNode = jsonNode.get(field);
		Assert.assertNotNull("Node not contains field \"" + field + "\"", chJsonNode); //$NON-NLS-1$ //$NON-NLS-2$
		Assert.assertEquals("Node type does not match for \"" + field + "\"", JsonNodeType.BOOLEAN, //$NON-NLS-1$ //$NON-NLS-2$
				chJsonNode.getNodeType());
		Assert.assertEquals("Node value does not match for \"" + field + "\"", expectedValue, jsonNode.booleanValue()); //$NON-NLS-1$ //$NON-NLS-2$
	}

	public static void checkFieldValue(String field, JsonNode jsonNode, Integer[] expectedValues) {
		JsonNode chJsonNode = jsonNode.get(field);
		Assert.assertNotNull("Node not contains field \"" + field + "\"", chJsonNode); //$NON-NLS-1$ //$NON-NLS-2$
		Assert.assertTrue("Field \"" + field + "\" not array", chJsonNode.isArray()); //$NON-NLS-1$ //$NON-NLS-2$
		Assert.assertArrayEquals("Invalid array node values", expectedValues, jsonNodeAsIntegerArray(chJsonNode)); //$NON-NLS-1$
	}

	public static void checkFieldValue(String field, JsonNode jsonNode, String[] expectedValues) {
		JsonNode chJsonNode = jsonNode.get(field);
		Assert.assertNotNull("Node not contains field \"" + field + "\"", chJsonNode); //$NON-NLS-1$ //$NON-NLS-2$
		Assert.assertTrue("Field \"" + field + "\" not array", chJsonNode.isArray()); //$NON-NLS-1$ //$NON-NLS-2$
		Assert.assertArrayEquals("Invalid array node values", expectedValues, jsonNodeAsStringArray(chJsonNode)); //$NON-NLS-1$
	}

	public static Integer[] jsonNodeAsIntegerArray(JsonNode node) {
		List<Integer> values = new LinkedList<Integer>();
		for (JsonNode v : node) {
			values.add(v.asInt());
		}
		Integer[] ints = new Integer[values.size()];
		return values.toArray(ints);
	}

	public static String[] jsonNodeAsStringArray(JsonNode node) {
		List<String> values = new LinkedList<String>();
		for (JsonNode v : node) {
			values.add(v.asText());
		}
		String[] ints = new String[values.size()];
		return values.toArray(ints);
	}

	public void isValidJsonSchema() throws Exception {
		ObjectMapper mapper = new ObjectMapper();
		mapper.enable(DeserializationFeature.FAIL_ON_READING_DUP_TREE_KEY);

		JsonNode jsonSchemeRoot = getRoot(mapper);
		System.out.println("GENERATED:\n " + jsonSchemeRoot);

		checkFieldValue(JSONSchemaKeywords.SCHEMA_VERSION_FIELD_NAME, jsonSchemeRoot,
				JSONSchemaKeywords.SCHEMA_VERSION_DEFAULT);
		checkFieldValue(JSONSchemaKeywords.TYPE, jsonSchemeRoot, JSONSchemaKeywords.TYPE_OBJECT);

		JsonNode propertiesRoot = jsonSchemeRoot.get(JSONSchemaKeywords.PROPERTIES);
		Assert.assertNotNull("\"" + JSONSchemaKeywords.PROPERTIES + "\" schema field not found", propertiesRoot); //$NON-NLS-1$ //$NON-NLS-2$
		Iterator<Entry<String, JsonNode>> it = propertiesRoot.fields();
		while (it.hasNext()) {
			Entry<String, JsonNode> entry = it.next();
			checkFieldValue(JSONSchemaKeywords.REF_FIELD_NAME, entry.getValue(),
					JSONSchemaKeywords.PROPERTIES_DEF_PREFIX + entry.getKey());
			Assert.assertNotNull("Object presented in \"properties\" bot not in \"definitions\"", //$NON-NLS-1$
					getDefinition(entry.getKey()));
		}
	}

	public JsonNode getDefinition(String name) throws Exception {
		JsonNode jsonSchemeRoot = getRoot();
		JsonNode definitionsRoot = jsonSchemeRoot.get(JSONSchemaKeywords.DEFINITIONS_FIELD_NAME);
		Assert.assertNotNull("\"" + JSONSchemaKeywords.DEFINITIONS_FIELD_NAME + "\" schema field not found", //$NON-NLS-1$ //$NON-NLS-2$
				definitionsRoot);
		JsonNode definition = definitionsRoot.get(name);
		Assert.assertNotNull("Definition \"" + name + "\" not found", definition); //$NON-NLS-1$ //$NON-NLS-2$
		return definition;
	}

	public static void checkStructureIdentical(JsonNode expected, JsonNode actual) {
		new JSONStructureChecker().checkStructureIdentical(expected, actual);
	}

	public static Matcher<JsonNode> nodeEqualsToYaml(final String expectedYaml)
			throws JsonProcessingException, IOException {
		return new NodeEqualsToYaml(expectedYaml);
	}

	private static class NodeEqualsToYaml extends BaseMatcher<JsonNode> {
		final JsonNode normalizedExpectedNode;

		public NodeEqualsToYaml(String expectedYaml) throws JsonProcessingException, IOException {
			normalizedExpectedNode = new ObjectMapper(new YAMLFactory()).readTree(expectedYaml);
		}

		@Override
		public boolean matches(Object item) {
			JsonNode node = (JsonNode) item;
			// if (!normalizedExpectedNode.equals(node.toString())) {
			// System.out.println("Expected: for " + normalizedExpectedNode);
			// try {
			// System.out.println(new ObjectMapper(new
			// YAMLFactory()).writeValueAsString(node));
			// } catch (JsonProcessingException e) {
			// // TODO Auto-generated catch block
			// e.printStackTrace();
			// }
			// }
			return normalizedExpectedNode.equals(node);
		}

		@Override
		public void describeTo(org.hamcrest.Description description) {
			description.appendText(normalizedExpectedNode.toString());
		}
	}
}
